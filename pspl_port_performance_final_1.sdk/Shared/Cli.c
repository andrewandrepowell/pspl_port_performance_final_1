/****************** Include Files (User Defined)  ********************/

#include "Cli.h"

#define BUFFER_SIZE				256
#define WRITE_BUFFER_SIZE		1024
#define HELP_CMD_PARAM_BOOL		"  [bool] Must either be 0 or 1."
#define HELP_CMD_PARAM_HA		"  [ha] Must be one of the following string of characters: ha_acp_0, ha_acp_1, ha_gp0_0, ha_hp0_0, ha_hp1_0, ha_hp2_0."
#define HELP_CMD_PARAM_LEN		"  [len] Must inclusively range from 2 to 256, in steps of power of 2."
#define HELP_CMD_PARAM_SIZE		"  [size] Must be greater than 0 and a multiple of the burst length multiplied by the AXI data width in bytes."
#define HELP_CMD_PARAM_OP_MOD 	"  [op_mod] Must be one of the following string of characters: separate, mixed, fully_mixed."
#define HELP_CMD_PARAM_MEM		"  [mem] Must be one of the following string of characters: ocm, ddr. "
#define HELP_CMD_PARAM_CACHE	"  [cache] Must be one of the following string of characters: so, sd, wt_nwa, wb_wa, wb_nwa, nc."
#define HELP_CMD_PARAM_ID		"  [id] Must be a value greater than 0."
#define HELP_CMD_PARAM_LOC		"  [loc] Must be a value greater than 0."
#define HELP_CMD_PARAM_DUM		"  [dum] Must be one of the following string of characters: dummy_0"

/********************** Globals (User Defined) ***********************/

static 	struct {
			int is_json:1;						/**< Flag indicating whether JSON-encoding is enabled. */
			int configure_cpu1_flag:1;			/**< Flag indicating whether commands are forwarded to the second cpu. */
			int capture_write_to_buffer_flag:1;	/**< Flag indicating whether the write commands buffer data instead of forwarding to virtual console. */
		} 									status_obj;
static	Io									io_obj;
static 	Io									err_io_obj;
static	Shared*								shd_obj = NULL;						/**< Pointer to the shared object for reaching cpu 1. */
static 	Task								tsk_tx_obj;							/**< Task for the virtual tx. */
static	Task								tsk_rx_obj;							/**< Task for the virutal rx. */
static 	Task								tsk_cli_obj;						/**< Task for cli (cpu 0). */
extern	int									pcEchoFlag;							/**< Toggles echoing with the console. */
extern 	int									pcCmdCharsFlag;						/**< Toggles extra character strings generated by the console. */
static	char								write_buffer[WRITE_BUFFER_SIZE];	/**< An intermediate buffer used for temporary storing messages. */

/*************** Function Prototypes (User Defined) ******************/

extern 	void 			vUARTCommandConsoleStart(uint16_t usStackSize, UBaseType_t uxPriority);
extern 	void			vVirtualCommandConsoleStart( uint16_t usStackSize, UBaseType_t uxPriority, UBaseType_t is_virtual );
extern 	TaskHandle_t 	vCommandGetTaskHandle();
extern 	void 			vOutputWrite(signed char * buffer, unsigned short buffer_size);
extern 	void 			vOutputWriteBlock(signed char * buffer, unsigned short buffer_size);
extern 	void 			vVirtualOutputWrite(signed char * buffer, unsigned short buffer_size);
extern 	void 			vVirtualOutputWriteBlock(signed char * buffer, unsigned short buffer_size);
extern 	int 			Main_request_operation();
extern	int 			Main_set_configure_smp(int is_smp_flag);
extern	int 			Main_set_hardware_enable(int hardware_identifier, int is_enabled_flag);
extern	int 			Main_set_hardware_location(int hardware_identifier, int location);
extern	int 			Main_set_hardware_params_burst_len(int hardware_identifier, int burst_len);
extern	int 			Main_set_hardware_params_transfer_size(int hardware_identifier, int transfer_size);
extern	int				Main_set_hardware_params_operation_mode(int hardware_identifier, int haom);
extern 	int 			Main_set_hardware_params_memory(int hardware_identifier, int memory_identifier);
extern 	int 			Main_set_hardware_cache_coherent(int hardware_identifier, int is_cache_coherent_flag);
extern 	int 			Main_get_hardware_identifier(char* string);
extern	const Hardware* Main_get_hardware(int hardware_identifier);
extern	int 			Main_set_memory_policies(int memory_identifier, int policy_0, int policy_1);
extern 	int 			Main_set_memory_transfer_size(int memory_identifier, int transfer_size);
extern 	int 			Main_get_memory_identifier(char* string);
extern	const Memory* 	Main_get_memory(int memory_identifier);
extern	const Synch* 	Main_get_synch();
extern 	int 			Main_set_dummy_task_enable(int dummy_task_identifier, int is_enabled_flag);
extern 	int 			Main_set_dummy_task_identifier(int dummy_task_identifier, int identifier);
extern	int 			Main_set_dummy_task_location(int dummy_task_identifier, int location);
extern	int 			Main_set_dummy_task_powersave(int dummy_task_identifier, int is_powersave_flag);
extern 	int 			Main_set_dummy_task_params_burst_len(int dummy_task_identifier, int burst_len);
extern 	int 			Main_set_dummy_task_params_transfer_size(int dummy_task_identifier, int transfer_size);
extern 	int 			Main_set_dummy_task_params_operation_mode(int dummy_task_identifier, int haom);
extern 	int 			Main_set_dummy_task_params_memory(int dummy_task_identifier, int memory_identifier);
extern 	int 			Main_get_dummy_task_identifier(char* string);
extern	const 			Dummy_Task* Main_get_dummy_task(int dummy_task_identifier);
static	size_t 			write(void* obj, void* buffer, size_t buffer_size);
static 	size_t 			write_block(void* obj, void* buffer, size_t buffer_size);
static 	portBASE_TYPE	set_json_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	set_configure_cpu1_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	set_configure_smp_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	request_operation_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_enable_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_location_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_params_burst_len_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_params_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_params_params_operation_mode_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_params_memory_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_cache_coherent_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	get_hardware_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_memory_policies_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_memory_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	get_memory_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	get_hard_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	get_synch_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_enable_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_identifier_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_location_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_powersave_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_params_burst_len_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_params_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_params_operation_mode_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_params_memory_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	get_dummy_task_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	char* 			get_operation_mode_as_string(Hardware_Accelerator_Operation_Mode oper_mode);
static 	char* 			get_cache_policy_as_string(Amp_PageAttribute cache_policy);
static 	char* 			get_parameter(const char *pcCommandString, int parameter_position);
static	int 			is_integer(char* nullTerminatedString);
static 	int 			get_operation_mode_identifier(char* string);
static 	int 			get_cache_policy_identifier(char* string);
static 	void 			set_status(char* pcWriteBuffer,size_t xWriteBufferLen,int is_success_flag);
static	void 			set_hard_report(char* pcWriteBuffer,size_t xWriteBufferLen);
static	void			set_report(char* pcWriteBuffer,size_t xWriteBufferLen);
static 	void 			task_virtual_handle_tx(void* param);
static 	void 			task_virtual_handle_rx(void* param);
		void 			Cli_Hardware_send_report(const Hardware* hde_obj);
		void 			Cli_Memory_send_report(const Memory* mry_obj);
		void 			Cli_Synch_send_report(const Synch* syn_obj);
		void 			Cli_Dummy_Task_send_report(const Dummy_Task* dmy_obj);

/**************** Type Definitions (User Defined) ********************/

static const CLI_Command_Definition_t set_json_struct = {
	"set_json",
	"\r\nset_json [bool]\r\n"
	" Sets the output to pretty-print or JavaScript Object Notation (JSON).\r\n"
	HELP_CMD_PARAM_BOOL " 0 indicates pretty-print is active, whereas 1 indicates JSON-encoding is active.\r\n"
	"\r\n",
	set_json_func,
	1
};

static const CLI_Command_Definition_t set_configure_cpu1_struct = {
	"set_configure_cpu1",
	"\r\nset_configure_cpu1 [bool]\r\n"
	" Sets the flag indicating whether or not certain commands are forwarded to the virtual command line of cpu 1.\r\n"
	HELP_CMD_PARAM_BOOL " 0 indicates cpu 0 is configurable, whereas 1 indicates some commands are forwarded to cpu 1.\r\n"
	"\r\n",
	set_configure_cpu1_func,
	1
};

static const CLI_Command_Definition_t set_configure_smp_struct = {
	"set_configure_smp",
	"\r\nset_configure_smp [bool]\r\n"
	" Sets the symmetric multiprocessing (SMP) bit.\r\n"
	HELP_CMD_PARAM_BOOL " 0 indicates indicates SMP bit is low, whereas 1 indicates SMP bit is high.\r\n"
	"\r\n",
	set_configure_smp_func,
	1
};

static const CLI_Command_Definition_t request_opteration_struct = {
	"request_operation",
	"\r\nrequest_operation\r\n"
	" Starts the operation, but only when at least one hardware accelerator is enabled.\r\n"
	"\r\n",
	request_operation_func,
	0
};

static const CLI_Command_Definition_t set_hardware_enable_struct = {
	"set_hardware_enable",
	"\r\nset_hardware_enable [ha] [bool]\r\n"
	" Sets the enable for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is a boolean value that specifies the enable state.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_BOOL "\r\n"
	"\r\n",
	set_hardware_enable_func,
	2
};

static const CLI_Command_Definition_t set_hardware_location_struct = {
	"set_hardware_location",
	"\r\nset_hardware_location [ha] [loc]\r\n"
	" Sets the location for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is an integer value that specifies the location.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_LOC "\r\n"
	"\r\n",
	set_hardware_location_func,
	2
};

static const CLI_Command_Definition_t set_hardware_params_burst_len_struct = {
	"set_hardware_params_burst_len",
	"\r\nset_hardware_params_burst_len [ha] [len]\r\n"
	" Sets the burst length for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is the burst length.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_LEN "\r\n"
	"\r\n",
	set_hardware_params_burst_len_func,
	2
};

static const CLI_Command_Definition_t set_hardware_params_transfer_size_struct = {
	"set_hardware_params_transfer_size",
	"\r\nset_hardware_params_transfer_size [ha] [size]\r\n"
	" Sets the transfer size for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is the transfer size.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_SIZE "\r\n"
	"\r\n",
	set_hardware_params_transfer_size_func,
	2
};

static const CLI_Command_Definition_t set_hardware_params_operation_mode_struct = {
	"set_hardware_params_operation_mode",
	"\r\nset_hardware_params_operation_mode [ha] [op_mod]\r\n"
	" Sets the operation mode for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is string that specifies the operation mode.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_OP_MOD "\r\n"
	"\r\n",
	set_hardware_params_params_operation_mode_func,
	2
};

static const CLI_Command_Definition_t set_hardware_params_memory_struct = {
	"set_hardware_params_memory",
	"\r\nset_hardware_params_memory [ha] [mem]\r\n"
	" Sets the memory for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is string that specifies the memory.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	"\r\n",
	set_hardware_params_memory_func,
	2
};

static const CLI_Command_Definition_t set_hardware_cache_coherent_struct = {
	"set_hardware_cache_coherent",
	"\r\nset_hardware_cache_coherent [ha] [bool]\r\n"
	" Sets the cache coherent for a specified hardware accelerator. Cache coherency is only available to the ACP. \n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is a boolean value that specifies the enable state.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_BOOL "\r\n"
	"\r\n",
	set_hardware_cache_coherent_func,
	2
};

static const CLI_Command_Definition_t get_hardware_report_struct = {
	"get_hardware_report",
	"\r\nget_hardware_report [ha]\r\n"
	" Gets the report for a specified hardware accelerator.\n\r"
	" The argument is string that specifies the hardware accelerator.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	"\r\n",
	get_hardware_report_func,
	1
};

static const CLI_Command_Definition_t set_memory_policies_struct = {
	"set_memory_policies",
	"\r\nset_memory_policies [mem] [cache] [cache]\r\n"
	" Sets the cache policies for a specified memory.\n\r"
	" The first argument is string that specifies the memory, whereas the next two string arguments respectively specify the L1 and L2 cache policies.\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	HELP_CMD_PARAM_CACHE "\r\n"
	HELP_CMD_PARAM_CACHE "\r\n"
	"\r\n",
	set_memory_policies_func,
	3
};

static const CLI_Command_Definition_t set_memory_transfer_size_struct = {
	"set_memory_transfer_size",
	"\r\nset_memory_transfer_size [mem] [size]\r\n"
	" Sets the maximum transfer size of a specified memory.\n\r"
	" The first argument is string that specifies the memory, whereas the next is the transfer size.\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	HELP_CMD_PARAM_SIZE "\r\n"
	"\r\n",
	set_memory_transfer_size_func,
	2
};

static const CLI_Command_Definition_t get_memory_report_struct = {
	"get_memory_report",
	"\r\nget_memory_report [mem]\r\n"
	" Gets the report for a specified memory.\n\r"
	" The argument is string that specifies the memory.\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	"\r\n",
	get_memory_report_func,
	1
};

static const CLI_Command_Definition_t get_hard_report_struct = {
	"get_hard_report",
	"\r\nget_hard_report\r\n"
	" Returns a report with the hard coded configurations, including clock speeds (not implemented).\n\r"
	"\r\n",
	get_hard_report_func,
	0
};

static const CLI_Command_Definition_t get_synch_report_struct = {
	"get_synch_report",
	"\r\nget_synch_report\r\n"
	" Gets the synch report.\n\r"
	"\r\n",
	get_synch_report_func,
	0
};

static const CLI_Command_Definition_t set_dummy_task_enable_struct = {
	"set_dummy_task_enable",
	"\r\nset_dummy_task_enable [dum] [bool]\r\n"
	" Sets the enable for the dummy task.\n\r"
	" The only argument is a boolean value that specifies the enable state.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_BOOL "\r\n"
	"\r\n",
	set_dummy_task_enable_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_identifier_struct = {
	"set_dummy_task_identifier",
	"\r\nset_dummy_task_identifier [dum] [id]\r\n"
	" Sets the identifier of the dummy task.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a value that specifies the identifier.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_ID "\r\n"
	"\r\n",
	set_dummy_task_identifier_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_location_struct = {
	"set_dummy_task_location",
	"\r\nset_dummy_task_location [dum] [loc]\r\n"
	" Sets the location of the dummy task.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a value that specifies the location.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_LOC "\r\n"
	"\r\n",
	set_dummy_task_location_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_powersave_struct = {
	"set_dummy_task_powersave",
	"\r\nset_dummy_task_powersave [dum] [bool]\r\n"
	" Sets whether the dummy task launches in powersave mode.\n\r"
	" The only argument is a boolean value that specifies the powersave state.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_BOOL "\r\n"
	"\r\n",
	set_dummy_task_powersave_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_params_burst_len_struct = {
	"set_dummy_task_params_burst_len",
	"\r\nset_dummy_task_params_burst_len [dum] [len]\r\n"
	" Sets the burst length of the dummy task in words.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a value that specifies the burst length.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_LEN "\r\n"
	"\r\n",
	set_dummy_task_params_burst_len_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_params_transfer_size_struct = {
	"set_dummy_task_params_transfer_size",
	"\r\nset_dummy_task_params_transfer_size [dum] [size]\r\n"
	" Sets the transfer size of the dummy task in bytes.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a value that specifies the transfer size.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_SIZE "\r\n"
	"\r\n",
	set_dummy_task_params_transfer_size_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_params_operation_mode_struct = {
	"set_dummy_task_params_operation_mode",
	"\r\nset_dummy_task_params_operation_mode [dum] [op_mod]\r\n"
	" Sets the operation mode of the dummy task.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a string that specifies the operation mode.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_OP_MOD "\r\n"
	"\r\n",
	set_dummy_task_params_operation_mode_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_params_memory_struct = {
	"set_dummy_task_params_memory",
	"\r\nset_dummy_task_params_memory [dum] [mem]\r\n"
	" Sets the operation mode of the dummy task.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a string that specifies the operation mode.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	"\r\n",
	set_dummy_task_params_memory_func,
	2
};

static const CLI_Command_Definition_t get_dummy_task_report_struct = {
	"get_dummy_task_report",
	"\r\nget_dummy_task_report [dum]\r\n"
	" Gets the report for the specified dummy task.\n\r"
	" The argument is a boolean value that specifies the dummy task.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	"\r\n",
	get_dummy_task_report_func,
	1
};

/*************** Function Definitions (User Defined) *****************/

void Cli_setup(Shared* shd_obj_0) {
	// Clear flags
	status_obj.is_json = 0;
	status_obj.configure_cpu1_flag = 0;
	status_obj.capture_write_to_buffer_flag = 0;
	// Register commands
	FreeRTOS_CLIRegisterCommand(&set_json_struct);
	FreeRTOS_CLIRegisterCommand(&set_configure_cpu1_struct);
	FreeRTOS_CLIRegisterCommand(&set_configure_smp_struct);
	FreeRTOS_CLIRegisterCommand(&request_opteration_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_enable_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_location_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_params_burst_len_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_params_transfer_size_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_params_memory_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_params_operation_mode_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_cache_coherent_struct);
	FreeRTOS_CLIRegisterCommand(&get_hardware_report_struct);
	FreeRTOS_CLIRegisterCommand(&set_memory_policies_struct);
	FreeRTOS_CLIRegisterCommand(&set_memory_transfer_size_struct);
	FreeRTOS_CLIRegisterCommand(&get_memory_report_struct);
	FreeRTOS_CLIRegisterCommand(&get_hard_report_struct);
	FreeRTOS_CLIRegisterCommand(&get_synch_report_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_enable_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_identifier_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_location_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_powersave_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_burst_len_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_transfer_size_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_operation_mode_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_memory_struct);
	FreeRTOS_CLIRegisterCommand(&get_dummy_task_report_struct);
	// Configure the console from FreeRTOS
	vVirtualCommandConsoleStart(TASK_LARGE_STACK_SIZE,tskIDLE_PRIORITY,0);
	// Directly configure the task object so that cpu 1 can wake up the cli on
	// cpu 0.
	tsk_cli_obj.lock_hdl = NULL;	// The lock is not needed.
	tsk_cli_obj.sync_hdl = xSemaphoreCreateBinary();
	tsk_cli_obj.task_hdl = vCommandGetTaskHandle();
	// Set the shared object
	shd_obj = shd_obj_0;
	Shared_set_task(shd_obj,&tsk_cli_obj);
	// Configure the io objects
	Io_setup(&io_obj,NULL,write,NULL,NULL);
	Io_setup(&err_io_obj,NULL,write_block,NULL,NULL);
}

void Clv_setup(Shared* shd_obj_0) {
	// Register commands
	FreeRTOS_CLIRegisterCommand(&set_configure_smp_struct);
	FreeRTOS_CLIRegisterCommand(&get_synch_report_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_enable_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_identifier_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_location_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_powersave_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_burst_len_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_transfer_size_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_operation_mode_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_memory_struct);
	FreeRTOS_CLIRegisterCommand(&get_dummy_task_report_struct);
	FreeRTOS_CLIRegisterCommand(&set_memory_policies_struct);
	FreeRTOS_CLIRegisterCommand(&set_memory_transfer_size_struct);
	FreeRTOS_CLIRegisterCommand(&get_memory_report_struct);
	// Set the shared object.
	shd_obj = shd_obj_0;
	// Configure the modified version of the console for acquiring messages
	// from cpu 0 and virtually sending them to cpu 1.
	//// Ensure json encoding is enabled.
	status_obj.is_json = 1;
	pcCmdCharsFlag = pcEchoFlag = (status_obj.is_json==0);
	//// Make sure cpu 1 doesn't try to forward commands to itself.
	status_obj.configure_cpu1_flag = 0;
	//// Initialize data related to the write buffer. The write buffer is necessary
	//// to store reports that can be forwarded back to cpu 0.
	status_obj.capture_write_to_buffer_flag = 0;
	//// Start the virtual console in virtual mode.
	vVirtualCommandConsoleStart(TASK_LARGE_STACK_SIZE,tskIDLE_PRIORITY,1);
	//// Configure the io objects
	Io_setup(&io_obj,NULL,write,NULL,NULL);
	Io_setup(&err_io_obj,NULL,write_block,NULL,NULL);
	//// Launch threads to handle the virtual serial driver. Keep in mind the
	//// the console needs to be launched first since it initializes queues on
	//// which the threads below.
	Task_setup(&tsk_tx_obj,task_virtual_handle_tx,&tsk_tx_obj,"tx task");
	Task_setup(&tsk_rx_obj,task_virtual_handle_rx,&tsk_rx_obj,"rx task");
	Shared_set_task(shd_obj,&tsk_rx_obj);
}

size_t write(void* obj, void* buffer, size_t buffer_size) {
	// It should be noted, despite the fact the buffer size can
	// be specified, this function is really intended to transfer
	// null-terminated character strings.
	// Also note this function is not fully thread-protected due to
	// the involvement of the capture_write_to_buffer_flag.
	(void) obj;
	if (status_obj.capture_write_to_buffer_flag) {
		configASSERT(buffer_size<=WRITE_BUFFER_SIZE);
		memcpy(write_buffer,buffer,buffer_size);
	} else {
		vVirtualOutputWrite(buffer,buffer_size);
	}
	return buffer_size;
}

size_t write_block(void* obj, void* buffer, size_t buffer_size) {
	// It should be noted, despite the fact the buffer size can
	// be specified, this function is really intended to transfer
	// null-terminated character strings.
	// Also note this function is not fully thread-protected due to
	// the involvement of the capture_write_to_buffer_flag.
	(void) obj;
	if (status_obj.capture_write_to_buffer_flag) {
		configASSERT(buffer_size<=WRITE_BUFFER_SIZE);
		memcpy(write_buffer,buffer,buffer_size);
	} else {
		vVirtualOutputWriteBlock(buffer,buffer_size);
	}
	return buffer_size;
}

void Cli_write_message(char* message) {
	if (status_obj.is_json==0) {
		Io_writeString(&io_obj,message);
		Io_writeString(&io_obj,"\n\r");
	} else {
		Io_writeFormattedString(&io_obj,
				"{"
				"\"type\": \"message\","
				"\"message\": \"%s\""
				"}",message);
	}
}

void Cli_write_message_formatted(char* message,...) {
	char buffer[BUFFER_SIZE];
	va_list args;
	va_start(args,message);
	if (status_obj.is_json==0) {
		Io_writeFormattedStringVariadic(&io_obj,message,&args);
		Io_writeString(&io_obj,"\n\r");
	} else {
		vsprintf(buffer,message,args);
		Io_writeFormattedString(&io_obj,
				"{"
				"\"type\": \"message\","
				"\"message\": \"%s\""
				"}",buffer);
	}
	va_end(args);
}

void Cli_write_assert(const char *file, int line) {
	if (status_obj.is_json==0) {
		Io_writeFormattedString(&err_io_obj,"An assertion failed in \"%s\" at line %d...\n\r",
				file,line);
	} else {
		Io_writeFormattedString(&err_io_obj,
				"{"
				"\"type\": \"assert\","
				"\"file\": \"%s\","
				"\"line\": %d"
				"}",file,line);
	}
}

portBASE_TYPE	set_json_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int is_json_flag;
	int result = 0;
	char* is_json_flag_as_string = get_parameter(pcCommandString,1);

	is_json_flag = (is_integer(is_json_flag_as_string))?atoi(is_json_flag_as_string):-1;
	if (is_json_flag>=0) {
		result = 1;
		status_obj.is_json = (is_json_flag!=0);
		pcCmdCharsFlag = pcEchoFlag = (is_json_flag==0);
	}
	free(is_json_flag_as_string);
	set_status(pcWriteBuffer,xWriteBufferLen,result);
	return pdFALSE;
}

portBASE_TYPE	set_configure_cpu1_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int configure_cpu1_flag;
	int result = 0;
	char* configure_cpu1_flag_as_string = get_parameter(pcCommandString,1);

	configure_cpu1_flag = (is_integer(configure_cpu1_flag_as_string))?atoi(configure_cpu1_flag_as_string):-1;
	if (configure_cpu1_flag>=0) {
		result = 1;
		status_obj.configure_cpu1_flag = (configure_cpu1_flag!=0);
	}
	free(configure_cpu1_flag_as_string);
	set_status(pcWriteBuffer,xWriteBufferLen,result);
	return pdFALSE;
}

portBASE_TYPE set_configure_smp_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int is_smp_flag;
	int result = 0;
	char* is_smp_flag_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {

		is_smp_flag_as_string = get_parameter(pcCommandString,1);
		is_smp_flag = (is_integer(is_smp_flag_as_string))?atoi(is_smp_flag_as_string):-1;

		if (is_smp_flag>=0) {
			result = Main_set_configure_smp(is_smp_flag);
		}

		free(is_smp_flag_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE request_operation_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {
	set_status(pcWriteBuffer,xWriteBufferLen,Main_request_operation());
	return pdFALSE;
}

portBASE_TYPE set_hardware_enable_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int is_enabled_flag;
	int result = 0;
	char* hardware_identifier_as_string	= get_parameter(pcCommandString,1);
	char* is_enabled_flag_as_string		= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	is_enabled_flag = (is_integer(is_enabled_flag_as_string))?atoi(is_enabled_flag_as_string):-1;

	if ((hardware_identifier>=0)&&(is_enabled_flag>=0)) {
		result = Main_set_hardware_enable(hardware_identifier,is_enabled_flag);
	}

	free(hardware_identifier_as_string);
	free(is_enabled_flag_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_location_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int location;
	int result = 0;
	char* hardware_identifier_as_string	= get_parameter(pcCommandString,1);
	char* location_as_string			= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	location = (is_integer(location_as_string))?atoi(location_as_string):-1;

	if ((hardware_identifier>=0)&&(location>=0)) {
		result = Main_set_hardware_location(hardware_identifier,location);
	}

	free(hardware_identifier_as_string);
	free(location_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_params_burst_len_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int burst_len;
	int result = 0;
	char* hardware_identifier_as_string	= get_parameter(pcCommandString,1);
	char* burst_len_as_string			= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	burst_len = (is_integer(burst_len_as_string))?atoi(burst_len_as_string):-1;

	if ((hardware_identifier>=0)&&(burst_len>=0)) {
		result = Main_set_hardware_params_burst_len(hardware_identifier,burst_len);
	}

	free(hardware_identifier_as_string);
	free(burst_len_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_params_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int transfer_size;
	int result = 0;
	char* hardware_identifier_as_string		= get_parameter(pcCommandString,1);
	char* transfer_size_as_string			= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	transfer_size = (is_integer(transfer_size_as_string))?atoi(transfer_size_as_string):-1;

	if ((hardware_identifier>=0)&&(transfer_size>=0)) {
		result = Main_set_hardware_params_transfer_size(hardware_identifier,transfer_size);
	}

	free(hardware_identifier_as_string);
	free(transfer_size_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_params_params_operation_mode_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int operation_mode_identifier;
	int result = 0;
	char* hardware_identifier_as_string			= get_parameter(pcCommandString,1);
	char* operation_mode_identifier_as_string	= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	operation_mode_identifier = get_operation_mode_identifier(operation_mode_identifier_as_string);

	if ((hardware_identifier>=0)&&(operation_mode_identifier>=0)) {
		result = Main_set_hardware_params_operation_mode(hardware_identifier,operation_mode_identifier);
	}

	free(hardware_identifier_as_string);
	free(operation_mode_identifier_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_params_memory_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int memory_identifier;
	int result = 0;
	char* hardware_identifier_as_string			= get_parameter(pcCommandString,1);
	char* memory_identifier_as_string			= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);

	if ((hardware_identifier>=0)&&(memory_identifier>=0)) {
		result = Main_set_hardware_params_memory(hardware_identifier,memory_identifier);
	}

	free(hardware_identifier_as_string);
	free(memory_identifier_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_cache_coherent_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int is_cache_coherent_flag;
	int result = 0;
	char* hardware_identifier_as_string			= get_parameter(pcCommandString,1);
	char* is_cache_coherent_flag_as_string		= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	is_cache_coherent_flag = (is_integer(is_cache_coherent_flag_as_string))?atoi(is_cache_coherent_flag_as_string):-1;

	if ((hardware_identifier>=0)&&(is_cache_coherent_flag>=0)) {
		result = Main_set_hardware_cache_coherent(hardware_identifier,is_cache_coherent_flag);
	}

	free(hardware_identifier_as_string);
	free(is_cache_coherent_flag_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE get_hardware_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int result = 0;
	size_t report_size;
	char* hardware_identifier_as_string;
	const Hardware* hde_obj;

	hardware_identifier_as_string = get_parameter(pcCommandString,1);
	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	hde_obj = Main_get_hardware(hardware_identifier);
	if (hde_obj != NULL) {
		result = 1;
		status_obj.capture_write_to_buffer_flag = 1;
		Cli_Hardware_send_report(hde_obj);
		status_obj.capture_write_to_buffer_flag = 0;
		set_report(pcWriteBuffer,xWriteBufferLen);
		report_size = strlen(pcWriteBuffer);
		pcWriteBuffer += report_size;
		xWriteBufferLen -= report_size;
	}

	free(hardware_identifier_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_memory_policies_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int memory_identifier;
	int policy_0_identifier;
	int policy_1_identifier;
	int result = 0;
	char* memory_identifier_as_string;
	char* policy_0_as_string;
	char* policy_1_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		memory_identifier_as_string			= get_parameter(pcCommandString,1);
		policy_0_as_string					= get_parameter(pcCommandString,2);
		policy_1_as_string					= get_parameter(pcCommandString,3);

		memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);
		policy_0_identifier = get_cache_policy_identifier(policy_0_as_string);
		policy_1_identifier = get_cache_policy_identifier(policy_1_as_string);

		if ((memory_identifier>=0)&&(policy_0_identifier>=0)&&(policy_1_identifier>=0)) {
			result = Main_set_memory_policies(memory_identifier,policy_0_identifier,policy_1_identifier);
		}

		free(memory_identifier_as_string);
		free(policy_0_as_string);
		free(policy_1_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_memory_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int memory_identifier;
	int transfer_size;
	int result = 0;
	char* memory_identifier_as_string;
	char* transfer_size_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		memory_identifier_as_string 			= get_parameter(pcCommandString,1);
		transfer_size_as_string					= get_parameter(pcCommandString,2);

		memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);
		transfer_size = (is_integer(transfer_size_as_string))?atoi(transfer_size_as_string):-1;

		if ((memory_identifier>=0)&&(transfer_size>=0)) {
			result = Main_set_memory_transfer_size(memory_identifier,transfer_size);
		}

		free(memory_identifier_as_string);
		free(transfer_size_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE get_memory_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int memory_identifier;
	int result = 0;
	size_t report_size;
	char* memory_identifier_as_string;
	const Memory* mry_obj;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		memory_identifier_as_string = get_parameter(pcCommandString,1);
		memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);
		mry_obj = Main_get_memory(memory_identifier);
		if (mry_obj != NULL) {
			result = 1;
			status_obj.capture_write_to_buffer_flag = 1;
			Cli_Memory_send_report(mry_obj);
			status_obj.capture_write_to_buffer_flag = 0;
			set_report(pcWriteBuffer,xWriteBufferLen);
			report_size = strlen(pcWriteBuffer);
			pcWriteBuffer += report_size;
			xWriteBufferLen -= report_size;
		}

		free(memory_identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE get_hard_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int current_size;
	set_hard_report(pcWriteBuffer,xWriteBufferLen);
	current_size = strlen(pcWriteBuffer);
	set_status(pcWriteBuffer+current_size,xWriteBufferLen-current_size,0);
	return pdFALSE;
}

static portBASE_TYPE get_synch_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int result = 0;
	size_t report_size;
	const Synch* syn_obj;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		syn_obj = Main_get_synch();
		if (syn_obj != NULL) {
			result = 1;
			status_obj.capture_write_to_buffer_flag = 1;
			Cli_Synch_send_report(syn_obj);
			status_obj.capture_write_to_buffer_flag = 0;
			set_report(pcWriteBuffer,xWriteBufferLen);
			report_size = strlen(pcWriteBuffer);
			pcWriteBuffer += report_size;
			xWriteBufferLen -= report_size;
		}

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_enable_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int is_enabled_flag;
	int dummy_task_identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* is_enabled_flag_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  		= get_parameter(pcCommandString,1);
		is_enabled_flag_as_string				= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		is_enabled_flag = (is_integer(is_enabled_flag_as_string))?atoi(is_enabled_flag_as_string):-1;

		if ((dummy_task_identifier>=0)&&(is_enabled_flag>=0)) {
			result = Main_set_dummy_task_enable(dummy_task_identifier,is_enabled_flag);
		}

		free(dummy_task_identifier_as_string);
		free(is_enabled_flag_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_identifier_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* identifier_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		identifier_as_string				= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		identifier = (is_integer(identifier_as_string))?atoi(identifier_as_string):-1;

		if ((dummy_task_identifier>=0)&&(identifier>=0)) {
			result = Main_set_dummy_task_identifier(dummy_task_identifier,identifier);
		}

		free(dummy_task_identifier_as_string);
		free(identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_location_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int location;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* location_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		location_as_string					= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		location = (is_integer(location_as_string))?atoi(location_as_string):-1;

		if ((dummy_task_identifier>=0)&&(location>=0)) {
			result = Main_set_dummy_task_location(dummy_task_identifier,location);
		}

		free(dummy_task_identifier_as_string);
		free(location_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_powersave_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int is_powersave_flag;
	int dummy_task_identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* is_powersave_flag_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  		= get_parameter(pcCommandString,1);
		is_powersave_flag_as_string				= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		is_powersave_flag = (is_integer(is_powersave_flag_as_string))?atoi(is_powersave_flag_as_string):-1;

		if ((dummy_task_identifier>=0)&&(is_powersave_flag>=0)) {
			result = Main_set_dummy_task_powersave(dummy_task_identifier,is_powersave_flag);
		}

		free(dummy_task_identifier_as_string);
		free(is_powersave_flag_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_params_burst_len_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int burst_len;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* burst_len_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		burst_len_as_string					= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		burst_len = (is_integer(burst_len_as_string))?atoi(burst_len_as_string):-1;

		if ((dummy_task_identifier>=0)&&(burst_len>=0)) {
			result = Main_set_dummy_task_params_burst_len(dummy_task_identifier,burst_len);
		}

		free(dummy_task_identifier_as_string);
		free(burst_len_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_params_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int transfer_size;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* transfer_size_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		transfer_size_as_string				= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		transfer_size = (is_integer(transfer_size_as_string))?atoi(transfer_size_as_string):-1;

		if ((dummy_task_identifier>=0)&&(transfer_size>=0)) {
			result = Main_set_dummy_task_params_transfer_size(dummy_task_identifier,transfer_size);
		}

		free(dummy_task_identifier_as_string);
		free(transfer_size_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_params_operation_mode_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int operation_mode_identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* operation_mode_identifier_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string			= get_parameter(pcCommandString,1);
		operation_mode_identifier_as_string		= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		operation_mode_identifier = get_operation_mode_identifier(operation_mode_identifier_as_string);

		if ((dummy_task_identifier>=0)&&(operation_mode_identifier>=0)) {
			result = Main_set_dummy_task_params_operation_mode(dummy_task_identifier,operation_mode_identifier);
		}

		free(dummy_task_identifier_as_string);
		free(operation_mode_identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_params_memory_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int memory_identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* memory_identifier_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		memory_identifier_as_string			= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);

		if ((dummy_task_identifier>=0)&&(memory_identifier>=0)) {
			result = Main_set_dummy_task_params_memory(dummy_task_identifier,memory_identifier);
		}

		free(dummy_task_identifier_as_string);
		free(memory_identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE get_dummy_task_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int result = 0;
	size_t report_size;
	char* dummy_task_identifier_as_string;
	const Dummy_Task* dmy_obj;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string = get_parameter(pcCommandString,1);
		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		dmy_obj = Main_get_dummy_task(dummy_task_identifier);
		if (dmy_obj != NULL) {
			result = 1;
			status_obj.capture_write_to_buffer_flag = 1;
			Cli_Dummy_Task_send_report(dmy_obj);
			status_obj.capture_write_to_buffer_flag = 0;
			set_report(pcWriteBuffer,xWriteBufferLen);
			report_size = strlen(pcWriteBuffer);
			pcWriteBuffer += report_size;
			xWriteBufferLen -= report_size;
		}

		free(dummy_task_identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

void Cli_Hardware_send_report(const Hardware* hde_obj) {
	const Counts* cts_obj = Hardware_Monitor_Counts_get(hde_obj);
	const Params* prs_obj = Hardware_Params_get(hde_obj);
	const Memory* mry_obj = Params_Memory_get(prs_obj);
	const Arm_Counts* acs_obj = Hardware_Arm_Counts_get(hde_obj);
	if (status_obj.is_json==0) {
		Io_writeFormattedString(&io_obj,
				"hardware           :\t%s\n\r"
				"burst length       :\t%u\n\r"
				"coherent           :\t%s\n\r"
				"transfer size      :\t%u\n\r"
				"operation mode     :\t%s\n\r"
				"memory             :\t%s\n\r"
				"result             :\t%s\n\r"
				"latency write total:\t%u\n\r"
				"latency read total :\t%u\n\r"
				"latency write min  :\t%u\n\r"
				"latency read min   :\t%u\n\r"
				"latency write max  :\t%u\n\r"
				"latency read max   :\t%u\n\r"
				"trans write total  :\t%u\n\r"
				"trans read total   :\t%u\n\r"
				"count total        :\t%u\n\r"
				"cpu write total    :\t%u\n\r"
				"cpu read total     :\t%u\n\r",
				Hardware_get_string(hde_obj),prs_obj->burst_len,
				(Hardware_is_cache_coherent(hde_obj)?"Yes":"No"),
				prs_obj->transfer_size,
				get_operation_mode_as_string(prs_obj->operation_mode),
				Memory_get_string(mry_obj),
				(Hardware_is_error(hde_obj)?"failure":"success"),
				cts_obj->latency.write.total,cts_obj->latency.read.total,
				cts_obj->latency.write.min,cts_obj->latency.read.min,
				cts_obj->latency.write.max,cts_obj->latency.read.max,
				cts_obj->transaction.write.total,cts_obj->transaction.read.total,
				cts_obj->count,
				acs_obj->latency.write.total,acs_obj->latency.read.total);
	} else {
		Io_writeFormattedString(&io_obj,
				"{\"type\":\"hardware_report\","
				"\"hardware\":\"%s\","
				"\"burst length\":%u,"
				"\"coherent\":\"%s\","
				"\"transfer size\":%u,"
				"\"operation mode\":\"%s\","
				"\"memory\":\"%s\","
				"\"result\":\"%s\","
				"\"latency write total\":%u,"
				"\"latency read total\":%u,"
				"\"latency write min\":%u,"
				"\"latency read min\":%u,"
				"\"latency write max\":%u,"
				"\"latency read max\":%u,"
				"\"trans write total\":%u,"
				"\"trans read total\":%u,"
				"\"count total\":%u,"
				"\"cpu write total\":%u,"
				"\"cpu read total\":%u}",
				Hardware_get_string(hde_obj),prs_obj->burst_len,
				(Hardware_is_cache_coherent(hde_obj)?"Yes":"No"),
				prs_obj->transfer_size,
				get_operation_mode_as_string(prs_obj->operation_mode),
				Memory_get_string(mry_obj),
				(Hardware_is_error(hde_obj)?"failure":"success"),
				cts_obj->latency.write.total,cts_obj->latency.read.total,
				cts_obj->latency.write.min,cts_obj->latency.read.min,
				cts_obj->latency.write.max,cts_obj->latency.read.max,
				cts_obj->transaction.write.total,cts_obj->transaction.read.total,
				cts_obj->count,
				acs_obj->latency.write.total,acs_obj->latency.read.total);
	}
}

void Cli_Memory_send_report(const Memory* mry_obj) {
	if (status_obj.is_json==0) {
		Io_writeFormattedString(&io_obj,
				"memory             :\t%s\n\r"
				"normal             :\t%s\n\r"
				"base address       :\t%x\n\r"
				"cache policy 0     :\t%s\n\r"
				"cache policy 1     :\t%s\n\r",
				Memory_get_string(mry_obj),(Memory_is_normal_memory(mry_obj)?"Yes":"No"),
				(const u32)Memory_get_base_address(mry_obj),
				get_cache_policy_as_string(Memory_get_cache_policy_0(mry_obj)),
				get_cache_policy_as_string(Memory_get_cache_policy_1(mry_obj)));
	} else {
		Io_writeFormattedString(&io_obj,
				"{\"type\":\"memory_report\","
				"\"memory\":\"%s\","
				"\"normal\":\"%s\","
				"\"base address\":%u,"
				"\"cache policy 0\":\"%s\","
				"\"cache policy 1\":\"%s\"}",
				Memory_get_string(mry_obj),(Memory_is_normal_memory(mry_obj)?"Yes":"No"),
				(const u32)Memory_get_base_address(mry_obj),
				get_cache_policy_as_string(Memory_get_cache_policy_0(mry_obj)),
				get_cache_policy_as_string(Memory_get_cache_policy_1(mry_obj)));
	}
}

void Cli_Synch_send_report(const Synch* syn_obj) {
#warning "You need to modify the source code such that you can check the smp bit for both processors!"
	const Arm_Counts* acs_obj = Synch_Arm_Counts_get(syn_obj);
	if (status_obj.is_json==0) {
		Io_writeFormattedString(&io_obj,
				"cpu latency total  :\t%u\n\r"
				"cpu sleep total    :\t%u\n\r"
				"smp bit            :\t%s\n\r",
				acs_obj->latency.total,acs_obj->latency.sleep,
				(Amp_get_actlr_smp()?"Yes":"No"));
	} else {
		Io_writeFormattedString(&io_obj,
				"{\"type\":\"synch_report\","
				"\"cpu latency total\":%u,"
				"\"cpu sleep total\":%u,"
				"\"smp bit\":\"%s\"}",
				acs_obj->latency.total,acs_obj->latency.sleep,
				(Amp_get_actlr_smp()?"Yes":"No"));
	}
}

void Cli_Dummy_Task_send_report(const Dummy_Task* dmy_obj) {
	const Params* prs_obj = Dummy_Task_Params_get(dmy_obj);
	const Memory* mry_obj = Params_Memory_get(prs_obj);
	if (status_obj.is_json==0) {
		Io_writeFormattedString(&io_obj,
				"dummy              :\t%s\n\r"
				"burst length       :\t%u\n\r"
				"transfer size      :\t%u\n\r"
				"operation mode     :\t%s\n\r"
				"powersave          :\t%s\n\r"
				"memory             :\t%s\n\r"
				"enabled            :\t%s\n\r",
				Dummy_Task_get_string(dmy_obj),
				prs_obj->burst_len,prs_obj->transfer_size,
				get_operation_mode_as_string(prs_obj->operation_mode),
				(Dummy_Task_get_is_powersave_flag(dmy_obj)?"Yes":"No"),
				Memory_get_string(mry_obj),
				(Dummy_Task_is_enabled(dmy_obj)?"Yes":"No"));
	} else {
		Io_writeFormattedString(&io_obj,
				"{\"type\":\"dummy_report\","
				"\"dummy\":\"%s\","
				"\"burst length\":%u,"
				"\"transfer size\":%u,"
				"\"operation mode\":\"%s\","
				"\"powersave\":\"%s\","
				"\"memory\":\"%s\","
				"\"enabled\":\"%s\"}",
				Dummy_Task_get_string(dmy_obj),
				prs_obj->burst_len,prs_obj->transfer_size,
				get_operation_mode_as_string(prs_obj->operation_mode),
				(Dummy_Task_get_is_powersave_flag(dmy_obj)?"Yes":"No"),
				Memory_get_string(mry_obj),
				(Dummy_Task_is_enabled(dmy_obj)?"Yes":"No"));
	}
}

void Cli_send_finish() {
	if (status_obj.is_json==0) {
		/* No need to send anything here. */
	} else {
		Io_writeString(&io_obj,"{\"type\":\"finish\"}");
	}
}

char* get_operation_mode_as_string(Hardware_Accelerator_Operation_Mode oper_mode) {
	switch (oper_mode) {
	case Hardware_Accelerator_Operation_Mode_SEPARATE: 	return "Separate";
	case Hardware_Accelerator_Operation_Mode_MIX: 		return "Mix";
	case Hardware_Accelerator_Operation_Mode_FULLY_MIX: return "Fully Mix";
	default: Xil_AssertNonvoidAlways();
	}
}

char* get_cache_policy_as_string(Amp_PageAttribute cache_policy) {
	switch (cache_policy) {
	case Amp_strongly_ordered:					return "Strongly Ordered";
	case Amp_shareable_device:					return "Shareable Device";
	case Amp_write_through_no_write_allocate: 	return "Write Through No Write Allocate";
	case Amp_write_back_no_write_allocate: 		return "Write Back No Write Allocate";
	case Amp_non_cacheable: 					return "Non-Cacheable";
	case Amp_write_back_write_allocate: 		return "Write Back Write Allocate";
	default: Xil_AssertNonvoidAlways();
	}
}

int is_integer(char* nullTerminatedString) {
	for (; *nullTerminatedString; nullTerminatedString++)
		if (!(*nullTerminatedString == '-' ||
				*nullTerminatedString == '+' ||
				isdigit((int)*nullTerminatedString)))
			return 0;
	return 1;
}

char* get_parameter(const char *pcCommandString, int parameter_position) {

	portBASE_TYPE paramsize;
	char* param;
	char* buffer;

	// Acquire the parameter
	param = (char*)FreeRTOS_CLIGetParameter(pcCommandString, parameter_position, &paramsize);
	buffer = malloc(paramsize+1);
	memcpy(buffer, param, paramsize);
	buffer[paramsize] = '\0';

	return buffer;
}

int get_operation_mode_identifier(char* string) {
		   if (!strcmp(string,"separate")) {
		return Hardware_Accelerator_Operation_Mode_SEPARATE;
	} else if (!strcmp(string,"mix")) {
		return Hardware_Accelerator_Operation_Mode_MIX;
	} else if (!strcmp(string,"fully_mix")) {
		return Hardware_Accelerator_Operation_Mode_FULLY_MIX;
	} else {
		return -1;
	}
}

int get_cache_policy_identifier(char* string) {
	   	   if (!strcmp(string,"so")) {
		return Amp_strongly_ordered;
	} else if (!strcmp(string,"sd")) {
		return Amp_shareable_device;
	} else if (!strcmp(string,"wt_nwa")) {
		return Amp_write_through_no_write_allocate;
	} else if (!strcmp(string,"wb_nwa")) {
		return Amp_write_back_no_write_allocate;
	} else if (!strcmp(string,"nc")) {
		return Amp_non_cacheable;
	} else if (!strcmp(string,"wb_wa")) {
		return Amp_write_back_write_allocate;
	} else {
		return -1;
	}
}

void set_status(char* pcWriteBuffer,size_t xWriteBufferLen,int is_success_flag) {
	char buffer[BUFFER_SIZE];
	char* result = (is_success_flag)?"succeeded":"failed";
	sprintf(buffer,(status_obj.is_json)?
			"{\"type\":\"status\",\"status\":\"%s\"}":
			"Status             :\t%s\n\r",result);
	Xil_AssertVoid(strlen(buffer)<xWriteBufferLen);
	strcpy(pcWriteBuffer,buffer);
}

void set_hard_report(char* pcWriteBuffer,size_t xWriteBufferLen)  {
	char buffer[BUFFER_SIZE];
	sprintf(buffer,(status_obj.is_json)?
				"{\"type\":\"hard_report\","
				"\"status\":\"%s\"}":
				"Status             :\t%s\n\r","Incomplete command");
	Xil_AssertVoid(strlen(buffer)<xWriteBufferLen);
	strcpy(pcWriteBuffer,buffer);
}

void set_report(char* pcWriteBuffer,size_t xWriteBufferLen) {
	Xil_AssertVoid(strlen(write_buffer)<xWriteBufferLen);
	strcpy(pcWriteBuffer,write_buffer);
}

void task_virtual_handle_tx(void* param) {

	(void) param;
	char tx_char[] = "\0";
	char* message_out = Shared_get_message_out(shd_obj);

	while (1) {
		xVirtualGetCharTx(FreeRTOS_CLI_COMM_PORT,(signed char*)tx_char);
		if (strcmp(tx_char,"\0")) {
			strcat(message_out,tx_char);
		} else {
			Shared_signal(shd_obj);
		}
	}

	// This task should never die.
	vTaskDelete(NULL);
}

void task_virtual_handle_rx(void* param) {

	(void) param;
	char* message_in = Shared_get_message_in(shd_obj);

	while (1) {
		Shared_wait(shd_obj);
		xVirtualPutStringRx(FreeRTOS_CLI_COMM_PORT,message_in);
		message_in[0] = '\0';
	}

	// This task should never die.
	vTaskDelete(NULL);
}
